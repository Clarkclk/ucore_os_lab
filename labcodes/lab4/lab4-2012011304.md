lab4 report
====

练习1
----

1.1 分配并初始化一个进程控制块。

按照实验指导书中“创建第0个内核线程”一节所述，对几个变量分别初始化即可。初始化代码如下所示：

```
        proc->state = PROC_UNINIT;
        proc->pid = -1;
        proc->runs = 0;
        proc->kstack = 0;
        proc->need_resched = 0;
        proc->parent = NULL;
        proc->mm = NULL;
        memset(&(proc->context), 0, sizeof(struct context));
        proc->tf = NULL;
        proc->cr3 = boot_cr3;
        proc->flags = 0;
        memset(proc->name, 0, PROC_NAME_LEN);
        ```

其中，大部分的成员变量都是直接赋初值0,只有state、pid和cr3应赋值为PROC_UNINIT、-1和boot_cr3。

1.2 请说明proc_struct中struct context context和struct trapframe *tf成员变量含义和在本实验中的作用是啥？

context表示进程的上下文，用于进程间切换时数据的保存；tf指向内核栈的某个位置，记录了进程在被中断前的状态，当内核跳回用户态时，恢复让进程继续执行的各寄存器。在本实验中，具体说来，tf为保存的该进程当前的栈帧，context为对应时刻的寄存器的值，这两个变量用于在进程切换时保存上下文无关数据。

练习2
----

2.1 为新创建的内核线程分配资源

先分配进程结构体，然后给进程分配内存管理相关的信息，最后将进程加入进程管理内。具体流程为

- 调用alloc_proc()函数，获取一个空的进程控制块，并检查时候成功获取。
- 设置该进程的父进程为当前进程
- 申请内核栈，并做检查
- 复制原进程的内存管理信息，并做检查
- 复制原进程的上下文信息
- 为进程分配一个pid
- 将进程置入哈希列表和进程列表中
- 唤醒进程，返回进程pid

2.2 请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。

要分析每个新fork的线程的id时候唯一，需要分析获得id的过程。在get_pid()函数中，

```
static int next_saft = MAX_PID, last_pid = MAX_PID;
```

完成了pid的申请，此时last_pid表示的是上一次申请的pid，就将pid+1作为本次申请的pid候选。并且进入循环以后，对进程列表中的pid有查重过程，如果有重复则last_pid++,直到last_pid在列表中不出现，然后返回last_pid.因此，每个新fork的线程的都有一个唯一的id。

练习3
----
3.1 阅读代码，理解 proc_run 函数和它调用的函数如何完成进程切换的。

在用proc_run切换进程的时候，首先切换的是内核栈，然后切换页表，最后改变上下文。当函数返回时，便会回到新进程的中断点了。

3.2 在本实验的执行过程中，创建且运行了几个内核线程？

2个，idleproc和initproc。idleproc在CPU不执行其他进程时运行，initproc是测试输出"Hello world"的进程，在屏幕上打印这句话，成功后退出。

3.3 语句local_intr_save(intr_flag);....local_intr_restore(intr_flag);在这里有何作用?请说明理由.

这2条语句用于关闭中断和恢复中断，在lab4中，ucore在向终端输出字符、分配物理页帧、释放页、进程调度时都会先关闭中断，操作完成后再开启中断。这样保证了切换时不会被时钟中断等中断打断，引起二次进程切换等问题。

与参考答案的区别
----

本次实验的实验指导书解释的非常详细，原理上并没有什么不同。在最开始的时候没有考虑到do_fork切换加入新进程时的关中断，在看了参考答案代码时，决定与参考答案保持一致，添加了该功能。

知识点
----

- 实验知识点：进程创建的具体细节和变量内容，以及fork的实现细节
- 原理知识点：进程管理的概念和具体进程管理需要记录那些信息来完成进程切换。这些记录的信息在上述实验的两个知识点中都是重要组成部分和设计思路。
- 未提到过的比较重要的原理知识点：进程的各种状态——挂起运行就绪等以及状态之间的控制切换没有涉及到。